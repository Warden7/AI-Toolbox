VList pureStrategies(const POMDP & pomdp, double epsilon) {
    const auto ir = MDP::computeImmediateRewards(pomdp);
    // This function produces a very simple lower bound for the POMDP. The
    // bound for each action is computed assuming to take the same action forever
    // (so the bound for action 0 assumes to forever take action 0, the bound for
    // action 1 assumes to take action 1, etc.).
    VList retval;

    for (size_t a = 0; a < pomdp.getA(); ++a) {
        auto newAlpha = Vector(pomdp.getS());
        auto oldAlpha = Vector(pomdp.getS());
        oldAlpha.fill(ir.col(a).minCoeff() / (1.0 - pomdp.getDiscount())); // FIXME: infinity

        while (true) {
            if constexpr(is_eigen_model<M>::value) {
                newAlpha = ir.row(s) + pomdp.getDiscount() * pomdp.getTransitionFunction(a) * oldAlpha;
            } else {
                newAlpha = ir.row(s);
                for (size_t s = 0; s < pomdp.getS(); ++s) {
                    double sum = 0.0;
                    for (size_t s1 = 0; s1 < pomdp.getS(); ++s1)
                        sum += pomdp.getTransitionProbability(s, a, s1) * oldAlpha[s1];
                    newAlpha[s] += pomdp.getDiscount() * sum;
                }
            }
            const auto variation = (oldAlpha - newAlpha).cwiseAbs().maxCoeff();
            if (variation < epsilon)
                break;

            oldAlpha = newAlpha;
        }
        retval.emplace_back(std::move(newAlpha), a, VObs(0));
    }
    retval.erase(extractDominated(S, retval., wend), std::end(w));
    return retval;
}

Matrix2D solveFIB(const POMDP & pomdp, const boost::multi_array<Matrix2D, 2> & pomdpSOSA, Matrix2D oldAlpha = Matrix2D()) {
    const auto ir = MDP::computeImmediateRewards(pomdp);
    Matrix2D newAlpha(S, A);

    if (oldAlpha.empty?) {
        oldAlpha.resize(S, A);
        oldAlpha.fill(ir.maxCoeff() / (1.0 / pomdp.getDiscount()));
    }

    while (true) {
        newAlpha.fill(0.0);
        for (size_t a = 0; a < pomdp.getA(); ++a)
            for (size_t o = 0; o < pomdp.getO(); ++o)
                newAlpha.col(a) += (pomdpSOSA(a, o) * oldAlpha).rowwise().maxCoeff();
        newAlpha *= pomdp.getDiscount();
        newAlpha += ir;
        // This is in the original MATLAB code
        newAlpha = coeffMin(newAlpha, oldAlpha);

        const auto variation = (oldAlpha - newAlpha).cwiseAbs().maxCoeff();
        if (variation < epsilon)
            break;

        oldAlpha = newAlpha;
    }
    return newAlpha;
}

void gapMin(POMDP pomdp, Belief initialBelief) {
    auto lbVList = pureStrategies(pomdp, eps);
    auto lbBeliefs = std::vector{initialBelief};

    auto pomdpSOSA = makeSOSA(pomdp); // Put this in utils (A,O --> S, S', see projecter)
    auto ubQ = solveFIB(pomdp, pomdpSOSA);
    fibQ = {ubQ, initialBelief * ubQ};
    ubV = {
        {initialBelief, fibQ.last().maxCoeff() }
    };

    // Init begin ub/lb
    double lb;
    findBestAtBelief(initialBelief, std::begin(lbVList), std::end(lbVList), &lb);
    auto ub = ubV[0].second;

    PBVI pbvi(model, 1, epsilon_);

    auto var = ub - lb;
    while (var >= epsilon_) {
        auto [newLbBeliefs, newUbBeliefs, newUbVals] = selectReachableBeliefs(model, lbVList, ubQ, ubV);

        if (newLbBeliefs.size() > 0) {
            lbBeliefs.append(newLbBeliefs);

            lbVList = pbvi(lbBeliefs, VFunction(lbVList)).back(); // can I std::move this?
            lbBeliefs.erase(extractUsefulBeliefs(
                std::begin(lbBeliefs), std::end(lbBeliefs),
                std::begin(lbVList), std::end(lbVList)),
                std::end(lbBeliefs)
            );

            findBestAtBelief(initialBelief, std::begin(lbVList), std::end(lbVList), &lb);
        }

        if (newUbBeliefs.size() > 0) {
            for (size_t i = 0; i < newUbBeliefs.size(); ++i) {
                ubV.emplace_back(std::move(newUbBeliefs[i]), newUbVals[i]);
                fibQ.emplace_back(A, newUbVals[i]);
            }

            newPOMDP, newPOMDPSOSA = makeNewPomdp(model, ubQ, ubV);
            fibQ = solveFIB(newPOMDP, newPOMDPSOSA, std::move(fibQ));

            ubQ = fibQ.subMatrix(S, A);
            for (size_t i = 0; i < ubV.size(); ++i)
                ubV[i] = fibQ.row(S+i).maxCoeff();

            cleanUp(ubQ, ubV, fibQ);
            ub = upperBound(initialBelief, ubQ, ubV);
        }

        if (newLbBeliefs.size() + newUbBeliefs.size() == 0)
            break;

        var = ub - lb;
    }
}

std::tuple<std::vector<Belief>, std::vector<Belief>, std::vector<double>> selectReachableBeliefs(const POMDP & pomdp, ...) {
    // Queue sorted by gap.         belief,    gap,   prob,    depth,       path
    using QueueElement = std::tuple<Belief, double, double, unsigned, std::vector<Belief>>;
    using QueueType = boost::heap::fibonacci_heap<QueueElement, boost::heap::compare<GapTupleLess>>;

    std::vector<Belief> newLbBeliefs, newUbBeliefs, visitedBeliefs;
    std::vector<double> newUbValues;

    constexpr size_t maxVisitedBeliefs = 1000;
    size_t overwriteCounter = 0;
    visitedBeliefs.reserve(maxVisitedBeliefs);

    QueueType queue;
    unsigned newBeliefs = 0;

    queue.push_back(initialBelief, 0.0, 1.0, 1, {});
    while (!queue.isEmpty() && newBeliefs < maxNewBeliefs) {
        const auto [belief, gap, beliefProbability, depth, path] = queue.top();
        queue.pop();

        // Limit history, we tend to go deeper so it shouldn't be too dangerous.
        if (visitedBeliefs.size() == maxVisitedBeliefs)
            visitedBeliefs[overwriteCounter++] = belief;
        else
            visitedBeliefs.push_back(belief);

        const auto [ubAction, ubActionValue] = bestPromisingAction(pomdp, belief, ubQ, ubV);
        const auto [lbAction, lbActionValue] = bestConservativeAction(pomdp, belief, lbVList);

        /***********************
         **     UPPER GAP     **
         ***********************/

        if (!(belief is in newUbBeliefs or belief is in ubV or belief is in corners)) {
            auto currentUpperBound = UB(belief, ubQ, ubV);
            if (ubActionValue < currentUpperBound) { // FIXME: Possibly eps
                uniquePath = beliefSetDiff(path,[ubBeliefSet;ub.beliefSet;corners]);
                values += ubActionValue;
                for (const auto & p : uniquePath)
                    values += UB(p, ubQ, ubV);
                ubBeliefSet += belief, std::move(uniquePath);

                ++newBeliefs;
            }
        }

        /***********************
         **     LOWER GAP     **
         ***********************/

        if (!(belief is in newLbBeliefs or belief is in lbVList)) {
            auto currentLowerBound = lowerBound(belief,lb.alphaVectors);
            if (lbActionValue > currentLowerBound) { // FIXME: possibly eps
                uniquePath = beliefSetDiff(path,[lbBeliefSet;lb.beliefSet]);

                lbBeliefSet += belief; std::move(uniquePath);

                ++newBeliefs;
            }
        }

        /***********************
         **  QUEUE EXPANSION  **
         ***********************/

        const auto intermediateBelief = (belief.transpose() * pomdp.getTransitionFunction(ubAction)).transpose();
        for (size_t o = 0; o < pomdp.getO(); ++o) {
            // Unnormalized here
            Belief nextBelief = intermediateBelief.cwiseProduct(pomdp.getObservationFunction(ubAction).col(o));

            const auto nextBeliefProbability = nextBelief.sum();
            if (checkEqual(sum, 0.0)) continue;
            // Now normalized
            nextBelief /= nextBeliefProbability;
            if (visitedBelief.contains(nextBelief)) continue;

            const auto ubValue = UB(nextBelief, ubQ, ubV);
            const auto lbValue = LB(nextBelief, lbVList);

            if ((ubValue - lbValue) * std::pow(pomdp.getDiscount(), depth) > eps * 20) {
                const auto nextBeliefOverallProbability = nextBeliefProbability * beliefProbability * pomdp.getDiscount();
                const auto nextBeliefGap = nextBeliefOverallProbability * (ubValue - lbValue);
                queue.emplace(
                    std::move(nextBelief),
                    nextBeliefGap,
                    nextBeliefOverallProbability,
                    depth+1,
                    path + belief
                ); // To add: ubValue + lbValue; double paths
            }
        }
    }

    return std::make_tuple(std::move(newLbBeliefs), std::move(newUbBeliefs), std::move(newUbValues));
}
