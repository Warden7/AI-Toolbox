Matrix2D solveFIB(const POMDP & pomdp, const boost::multi_array<Matrix2D, 2> & pomdpSOSA, Matrix2D oldAlpha = Matrix2D()) {
    const auto ir = MDP::computeImmediateRewards(pomdp);
    Matrix2D newAlpha(S, A);

    if (oldAlpha.empty?) {
        oldAlpha.resize(S, A);
        oldAlpha.fill(ir.maxCoeff() / (1.0 / pomdp.getDiscount()));
    }

    while (true) {
        newAlpha.fill(0.0);
        for (size_t a = 0; a < pomdp.getA(); ++a)
            for (size_t o = 0; o < pomdp.getO(); ++o)
                newAlpha.col(a) += (pomdpSOSA(a, o) * oldAlpha).rowwise().maxCoeff();
        newAlpha *= pomdp.getDiscount();
        newAlpha += ir;
        // This is in the original MATLAB code
        newAlpha = coeffMin(newAlpha, oldAlpha);

        const auto variation = (oldAlpha - newAlpha).cwiseAbs().maxCoeff();
        if (variation < epsilon)
            break;

        oldAlpha = newAlpha;
    }
    return newAlpha;
}

void gapMin(POMDP pomdp, Belief initialBelief) {
    BlindStrategies bs(1000000, eps);
    auto lbVList = bs(pomdp, true);
    {
        const auto unwrap = +[](VEntry & ve) -> MDP::Values & {return std::get<VALUES>(ve);};
        const auto rbegin = boost::make_transform_iterator(std::begin(lbVList), unwrap);
        const auto rend   = boost::make_transform_iterator(std::end  (lbVList), unwrap);

        lbVList.erase(extractDominated(m.getS(), rbegin, rend).base(), std::end(lbVList));
    }

    auto lbBeliefs = std::vector{initialBelief};

    auto pomdpSOSA = makeSOSA(pomdp); // Put this in utils (A,O --> S, S', see projecter)
    auto ubQ = solveFIB(pomdp, pomdpSOSA);
    fibQ = {ubQ, initialBelief * ubQ};
    ubV = {
        {initialBelief, fibQ.last().maxCoeff()}
    };

    // Init begin ub/lb
    double lb;
    findBestAtBelief(initialBelief, std::begin(lbVList), std::end(lbVList), &lb);
    auto ub = ubV[0].second;

    PBVI pbvi(model, 1, epsilon_);

    auto var = ub - lb;
    while (var >= epsilon_) {
        auto [newLbBeliefs, newUbBeliefs, newUbVals] = selectReachableBeliefs(model, lbVList, ubQ, ubV);

        if (newLbBeliefs.size() > 0) {
            lbBeliefs.append(newLbBeliefs);

            lbVList = pbvi(lbBeliefs, VFunction(lbVList)).back(); // can I std::move this?
            lbBeliefs.erase(extractUsefulBeliefs(
                std::begin(lbBeliefs), std::end(lbBeliefs),
                std::begin(lbVList), std::end(lbVList)),
                std::end(lbBeliefs)
            );

            findBestAtBelief(initialBelief, std::begin(lbVList), std::end(lbVList), &lb);
        }

        if (newUbBeliefs.size() > 0) {
            for (size_t i = 0; i < newUbBeliefs.size(); ++i) {
                ubV.emplace_back(std::move(newUbBeliefs[i]), newUbVals[i]);
                fibQ.emplace_back(A, newUbVals[i]);
            }

            newPOMDP, newPOMDPSOSA = makeNewPomdp(model, ubQ, ubV);
            fibQ = solveFIB(newPOMDP, newPOMDPSOSA, std::move(fibQ));

            ubQ = fibQ.subMatrix(S, A);
            for (size_t i = 0; i < ubV.size(); ++i)
                ubV[i] = fibQ.row(S+i).maxCoeff();

            cleanUp(ubQ, ubV, fibQ);
            ub = upperBound(initialBelief, ubQ, ubV);
        }

        if (newLbBeliefs.size() + newUbBeliefs.size() == 0)
            break;

        var = ub - lb;
    }
}

std::tuple<double, Vector> UB(const Belief & belief, const MDP::QFunction & ubQ, ubV) {
    double ubVal = (belief * ubQ).maxCoeff();

    std::vector<size_t> zeroStates;
    for (size_t s = 0; s < belief.size(); ++s)
        if (checkEqualSmall(belief[s], 0.0))
            zeroStates.push_back(s);

    std::vector<size_t> compatibleBeliefs;
    for (size_t i = 0; i < ubV.size(); ++i) {
        bool add = true;
        for (const auto s : zeroStates) {
            if (checkDifferentSmall(ubV[i].first[s], 0.0)) {
                add = false;
                break;
            }
        }
        if (add) compatibleBeliefs.push_back(i);
    }

    // There's no other beliefs on the same plane as this one, so the V can't
    // help us with the bound.
    if (compatibleBeliefs.size() == 0) {
        Vector retval(belief.size() + ubV.size());
        for (size_t s = 0; s < belief.size(); ++s)
            retval[s] = belief[s];
        for (size_t s = belief.size(); s < ubV.size(); ++s)
            retval[s] = 0.0;
        return std::make_tuple(ubVal, std::move(retval));
    }

    // Set columns = compatibleBeliefs.size() + 1; // One column per belief, plus one.
    // Set rows = belief.size() - zeroStates.size() + 1; // One row per state, plus one.
    for (const auto b : compatibleBeliefs) {
        size_t i = 0;
        for (const auto s : zeroStates)
            lp.row[i++] = ubV[b].first[s];
        lp.push_row(EQ, belief[s]);
    }

    size_t i = 0;
    for (const auto b : compatibleBeliefs) {
        double val = ubV[b].second;
        for (const auto s : zeroStates)
            val -= ubV[b].first[s] * cornerVal[s];
        lp.row[i++] = val;
    }
    lp.row[i] = -1.0;
    lp.push_row(EQ, 0.0);
}

std::tuple<std::vector<Belief>, std::vector<Belief>, std::vector<double>> selectReachableBeliefs(const POMDP & pomdp, ...) {
    // Queue sorted by gap.         belief,    gap,   prob,    depth,       path
    using QueueElement = std::tuple<Belief, double, double, unsigned, std::vector<Belief>>;
    using QueueType = boost::heap::fibonacci_heap<QueueElement, boost::heap::compare<GapTupleLess>>;

    std::vector<Belief> newLbBeliefs, newUbBeliefs, visitedBeliefs;
    std::vector<double> newUbValues;

    constexpr size_t maxVisitedBeliefs = 1000;
    size_t overwriteCounter = 0;
    visitedBeliefs.reserve(maxVisitedBeliefs);

    QueueType queue;
    unsigned newBeliefs = 0;

    queue.push_back(initialBelief, 0.0, 1.0, 1, {});
    while (!queue.isEmpty() && newBeliefs < maxNewBeliefs) {
        const auto [belief, gap, beliefProbability, depth, path] = queue.top();
        queue.pop();

        // Limit history, we tend to go deeper so it shouldn't be too dangerous.
        if (visitedBeliefs.size() == maxVisitedBeliefs)
            visitedBeliefs[overwriteCounter++] = belief;
        else
            visitedBeliefs.push_back(belief);

        const auto [ubAction, ubActionValue] = bestPromisingAction(pomdp, belief, ubQ, ubV);
        const auto [lbAction, lbActionValue] = bestConservativeAction(pomdp, belief, lbVList);

        /***********************
         **     UPPER GAP     **
         ***********************/

        if (!(belief is in newUbBeliefs or belief is in ubV or belief is in corners)) {
            auto currentUpperBound = UB(belief, ubQ, ubV);
            if (ubActionValue < currentUpperBound) { // FIXME: Possibly eps
                uniquePath = beliefSetDiff(path,[ubBeliefSet;ub.beliefSet;corners]);
                values += ubActionValue;
                for (const auto & p : uniquePath)
                    values += UB(p, ubQ, ubV);
                ubBeliefSet += belief, std::move(uniquePath);

                ++newBeliefs;
            }
        }

        /***********************
         **     LOWER GAP     **
         ***********************/

        if (!(belief is in newLbBeliefs or belief is in lbVList)) {
            auto currentLowerBound = lowerBound(belief,lb.alphaVectors);
            if (lbActionValue > currentLowerBound) { // FIXME: possibly eps
                uniquePath = beliefSetDiff(path,[lbBeliefSet;lb.beliefSet]);

                lbBeliefSet += belief; std::move(uniquePath);

                ++newBeliefs;
            }
        }

        /***********************
         **  QUEUE EXPANSION  **
         ***********************/

        const auto intermediateBelief = (belief.transpose() * pomdp.getTransitionFunction(ubAction)).transpose();
        for (size_t o = 0; o < pomdp.getO(); ++o) {
            // Unnormalized here
            Belief nextBelief = intermediateBelief.cwiseProduct(pomdp.getObservationFunction(ubAction).col(o));

            const auto nextBeliefProbability = nextBelief.sum();
            if (checkEqual(sum, 0.0)) continue;
            // Now normalized
            nextBelief /= nextBeliefProbability;
            if (visitedBelief.contains(nextBelief)) continue;

            const auto ubValue = UB(nextBelief, ubQ, ubV);
            const auto lbValue = LB(nextBelief, lbVList);

            if ((ubValue - lbValue) * std::pow(pomdp.getDiscount(), depth) > eps * 20) {
                const auto nextBeliefOverallProbability = nextBeliefProbability * beliefProbability * pomdp.getDiscount();
                const auto nextBeliefGap = nextBeliefOverallProbability * (ubValue - lbValue);
                queue.emplace(
                    std::move(nextBelief),
                    nextBeliefGap,
                    nextBeliefOverallProbability,
                    depth+1,
                    path + belief
                ); // To add: ubValue + lbValue; double paths
            }
        }
    }

    return std::make_tuple(std::move(newLbBeliefs), std::move(newUbBeliefs), std::move(newUbValues));
}
